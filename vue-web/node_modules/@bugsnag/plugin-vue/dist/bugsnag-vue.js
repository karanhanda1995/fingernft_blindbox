(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.BugsnagPluginVue = f()}})(function(){var define,module,exports;
var _this = this,
    _ErrorTypeStrings;

var _$vue_2 = function (app, client) {
  var prev = app.config.errorHandler;

  var handler = function (err, vm, info) {
    var handledState = {
      severity: 'error',
      unhandled: true,
      severityReason: {
        type: 'unhandledException'
      }
    };
    var event = client.Event.create(err, true, handledState, 'vue error handler', 1);
    event.addMetadata('vue', {
      errorInfo: ErrorTypeStrings[info] || info,
      component: vm ? formatComponentName(vm, true) : undefined,
      props: vm && vm.$options ? vm.$options.propsData : undefined
    });

    client._notify(event);

    if (typeof console !== 'undefined' && typeof console.error === 'function') console.error(err);
    if (typeof prev === 'function') prev.call(_this, err, vm, info);
  };

  app.config.errorHandler = handler;
};

function formatComponentName(vm) {
  if (vm.$parent === null) return 'App';
  return vm.$options && vm.$options.name ? vm.$options.name : 'Anonymous';
} // We copy in the following data structures from Vue's source so we can map the "info" parameter in the errorhandler
// callback (which is supplied as either a string or int) back to something meaningful
// https://github.com/vuejs/vue-next/blob/d5cce47789db8f37b9f5f8ea6602ea63e3a04b07/packages/runtime-core/src/component.ts#L153-L167


var LifecycleHooks = {
  BEFORE_CREATE: 'bc',
  CREATED: 'c',
  BEFORE_MOUNT: 'bm',
  MOUNTED: 'm',
  BEFORE_UPDATE: 'bu',
  UPDATED: 'u',
  BEFORE_UNMOUNT: 'bum',
  UNMOUNTED: 'um',
  DEACTIVATED: 'da',
  ACTIVATED: 'a',
  RENDER_TRIGGERED: 'rtg',
  RENDER_TRACKED: 'rtc',
  ERROR_CAPTURED: 'ec'
}; // https://github.com/vuejs/vue-next/blob/d5cce47789db8f37b9f5f8ea6602ea63e3a04b07/packages/runtime-core/src/errorHandling.ts#L6-L24

var ErrorCodes = {
  SETUP_FUNCTION: 0,
  RENDER_FUNCTION: 1,
  WATCH_GETTER: 2,
  WATCH_CALLBACK: 3,
  WATCH_CLEANUP: 4,
  NATIVE_EVENT_HANDLER: 5,
  COMPONENT_EVENT_HANDLER: 6,
  VNODE_HOOK: 7,
  DIRECTIVE_HOOK: 8,
  TRANSITION_HOOK: 9,
  APP_ERROR_HANDLER: 10,
  APP_WARN_HANDLER: 11,
  FUNCTION_REF: 12,
  ASYNC_COMPONENT_LOADER: 13,
  SCHEDULER: 14
}; // https://github.com/vuejs/vue-next/blob/d5cce47789db8f37b9f5f8ea6602ea63e3a04b07/packages/runtime-core/src/errorHandling.ts#L26-L57

var ErrorTypeStrings = (_ErrorTypeStrings = {}, _ErrorTypeStrings[LifecycleHooks.BEFORE_CREATE] = 'beforeCreate hook', _ErrorTypeStrings[LifecycleHooks.CREATED] = 'created hook', _ErrorTypeStrings[LifecycleHooks.BEFORE_MOUNT] = 'beforeMount hook', _ErrorTypeStrings[LifecycleHooks.MOUNTED] = 'mounted hook', _ErrorTypeStrings[LifecycleHooks.BEFORE_UPDATE] = 'beforeUpdate hook', _ErrorTypeStrings[LifecycleHooks.UPDATED] = 'updated', _ErrorTypeStrings[LifecycleHooks.BEFORE_UNMOUNT] = 'beforeUnmount hook', _ErrorTypeStrings[LifecycleHooks.UNMOUNTED] = 'unmounted hook', _ErrorTypeStrings[LifecycleHooks.ACTIVATED] = 'activated hook', _ErrorTypeStrings[LifecycleHooks.DEACTIVATED] = 'deactivated hook', _ErrorTypeStrings[LifecycleHooks.ERROR_CAPTURED] = 'errorCaptured hook', _ErrorTypeStrings[LifecycleHooks.RENDER_TRACKED] = 'renderTracked hook', _ErrorTypeStrings[LifecycleHooks.RENDER_TRIGGERED] = 'renderTriggered hook', _ErrorTypeStrings[ErrorCodes.SETUP_FUNCTION] = 'setup function', _ErrorTypeStrings[ErrorCodes.RENDER_FUNCTION] = 'render function', _ErrorTypeStrings[ErrorCodes.WATCH_GETTER] = 'watcher getter', _ErrorTypeStrings[ErrorCodes.WATCH_CALLBACK] = 'watcher callback', _ErrorTypeStrings[ErrorCodes.WATCH_CLEANUP] = 'watcher cleanup function', _ErrorTypeStrings[ErrorCodes.NATIVE_EVENT_HANDLER] = 'native event handler', _ErrorTypeStrings[ErrorCodes.COMPONENT_EVENT_HANDLER] = 'component event handler', _ErrorTypeStrings[ErrorCodes.VNODE_HOOK] = 'vnode hook', _ErrorTypeStrings[ErrorCodes.DIRECTIVE_HOOK] = 'directive hook', _ErrorTypeStrings[ErrorCodes.TRANSITION_HOOK] = 'transition hook', _ErrorTypeStrings[ErrorCodes.APP_ERROR_HANDLER] = 'app errorHandler', _ErrorTypeStrings[ErrorCodes.APP_WARN_HANDLER] = 'app warnHandler', _ErrorTypeStrings[ErrorCodes.FUNCTION_REF] = 'ref function', _ErrorTypeStrings[ErrorCodes.ASYNC_COMPONENT_LOADER] = 'async component loader', _ErrorTypeStrings[ErrorCodes.SCHEDULER] = 'scheduler flush. This is likely a Vue internals bug. ' + 'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next', _ErrorTypeStrings);

var _$vue2_3 = {};
var ___this_3 = this;

_$vue2_3 = function (Vue, client) {
  var prev = Vue.config.errorHandler;

  var handler = function (err, vm, info) {
    var handledState = {
      severity: 'error',
      unhandled: true,
      severityReason: {
        type: 'unhandledException'
      }
    };
    var event = client.Event.create(err, true, handledState, 'vue error handler', 1);
    event.addMetadata('vue', {
      errorInfo: info,
      component: vm ? __formatComponentName_3(vm, true) : undefined,
      props: vm ? vm.$options.propsData : undefined
    });

    client._notify(event);

    if (typeof console !== 'undefined' && typeof console.error === 'function') console.error(err);
    if (typeof prev === 'function') prev.call(___this_3, err, vm, info);
  };

  Vue.config.errorHandler = handler;
}; // taken and reworked from Vue.js source


var __formatComponentName_3 = function (vm, includeFile) {
  if (vm.$root === vm) return '<Root>';
  var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
  var name = options.name || options._componentTag;
  var file = options.__file;

  if (!name && file) {
    var match = file.match(/([^/\\]+)\.vue$/);
    name = match && match[1];
  }

  return (name ? '<' + classify(name) + '>' : '<Anonymous>') + (file && includeFile !== false ? ' at ' + file : '');
}; // taken and reworked from Vue.js source


var classify = _$vue2_3.classify = function (str) {
  return str.replace(/(?:^|[-_])(\w)/g, function (c) {
    return c.toUpperCase();
  }).replace(/[-_]/g, '');
};

var _$src_1 = {};
/* removed: var _$vue2_3 = require('./vue2'); */;

/* removed: var _$vue_2 = require('./vue'); */;

_$src_1 = /*#__PURE__*/function () {
  function BugsnagPluginVue() {
    // Fetch Vue from the window object, if it exists
    var globalVue = typeof window !== 'undefined' && window.Vue;
    this.name = 'vue';
    this.lazy = arguments.length === 0 && !globalVue;

    if (!this.lazy) {
      this.Vue = (arguments.length <= 0 ? undefined : arguments[0]) || globalVue;
      if (!this.Vue) throw new Error('@bugsnag/plugin-vue reference to `Vue` was undefined');
    }
  }

  var _proto = BugsnagPluginVue.prototype;

  _proto.load = function load(client) {
    if (this.Vue) {
      _$vue2_3(this.Vue, client);
      return {
        installVueErrorHandler: function () {
          return client._logger.warn('installVueErrorHandler() was called unnecessarily');
        }
      };
    }

    return {
      install: function (app) {
        if (!app) client._logger.error(new Error('@bugsnag/plugin-vue reference to Vue `app` was undefined'));
        _$vue_2(app, client);
      },
      installVueErrorHandler: function (Vue) {
        if (!Vue) client._logger.error(new Error('@bugsnag/plugin-vue reference to `Vue` was undefined'));
        _$vue2_3(Vue, client);
      }
    };
  };

  return BugsnagPluginVue;
}(); // add a default export for ESM modules without interop


_$src_1["default"] = _$src_1;

return _$src_1;

});
//# sourceMappingURL=bugsnag-vue.js.map
